#!/usr/bin/env python


import sys
import argparse
import pandas as pd
import shlex
import subprocess
import logging
import io
import json
from ddot import Ontology


logger = logging.getLogger('runddot')


def _parse_arguments(desc, args):
    """Parses command line arguments"""
    help_formatter = argparse.RawDescriptionHelpFormatter
    parser = argparse.ArgumentParser(description=desc,
                                     formatter_class=help_formatter)

    parser.add_argument('input', help='Input file in 3 column format'
                                      'expected by clixo')
    parser.add_argument('--ndexserver', default='test.ndexbio.org',
                        help='NDEx server to upload ontology to (default test.ndexbio.org')
    parser.add_argument('--ndexuser', default='scratch2',
                        help='NDEx username (default scratch2)')
    parser.add_argument('--ndexpass', default='scratch2',
                        help='NDEx password (default scratch2)')
    parser.add_argument('--ndexname', default='MODY',
                        help='Name to give network on NDEx (default MODY)')
    parser.add_argument('--ndexlayout', default='bubble-collect',
                        help='Layout of network on NDEx (default bubble-collect)')
    parser.add_argument('--ndexvisibility', default='PUBLIC',
                        help='Visibility of network on NDEx (default PUBLIC)')
    parser.add_argument('--alpha', default=0.01, type=float,
                        help='Clixo alpha parameter (default 0.01)')
    parser.add_argument('--beta', default=0.5, type=float,
                        help='Clixo beta parameter (default 0.5)')
    parser.add_argument('--clixopath', default='/opt/conda/lib/python3.7/'
                                               'site-packages/ddot/clixo_0'
                                               '.3/clixo',
                        help='Path to clixo command in docker image (defa'
                             'ult /opt/conda/lib/python3.7/site-packages/'
                             'ddot/clixo_0.3/clixo')
    return parser.parse_args(args)


def run_clixo(clixopath, inputfile, alpha, beta):
    """
    Runs clixo
    :param clixopath:
    :param alpha:
    :param beta:
    :param inputfile:
    :param outputfile:
    :return:
    """
    cmd_to_run = clixopath + ' ' + inputfile + ' ' + str(alpha) + ' ' + str(beta)
    logger.debug(cmd_to_run)
    p = subprocess.Popen(shlex.split(cmd_to_run),
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)

    out, err = p.communicate()
    return p.returncode, out, err


def run_ddot(theargs):
    try:
        (e_code, c_out, c_err) = run_clixo(theargs.clixopath, theargs.input, theargs.alpha, theargs.beta)
        df = pd.read_csv(io.StringIO(c_out.decode('utf-8')), sep='\t',
                         engine='python', header=None, comment='#')
        ont1 = Ontology.from_table(df, clixo_format=True, parent=0, child=1)

        ont_url, G = ont1.to_ndex(name=theargs.ndexname,
                                  ndex_server='http://' + theargs.ndexserver,
                                  ndex_pass=theargs.ndexuser,
                                  ndex_user=theargs.ndexpass,
                                  layout=theargs.ndexlayout,
                                  visibility=theargs.ndexvisibility)

        return {'ndexurl': ont_url.strip().replace('/v2/network/',
                                                   '/#/network/')}
    except OverflowError as ofe:
        logger.exception('Error running clixo')
        return {'error': str(ofe)}
    except Exception as e:
        logger.exception('Some other error')
        return {'error': str(e)}

    return {'error': 'unknown error'}


def main(args):
    """Main entry point"""
    desc = """
    Runs tasks generated by DDOT REST service

    """
    theargs = _parse_arguments(desc, args[1:])
    theargs.program = args[0]
    theargs.version = 'unknown'

    res = run_ddot(theargs)
    if res == '':
        return 1
    json.dump(res, sys.stdout)
    return 0


if __name__ == '__main__':
    sys.exit(main(sys.argv))
