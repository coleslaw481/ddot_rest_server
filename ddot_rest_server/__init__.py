# -*- coding: utf-8 -*-

"""Top-level package for ddot_rest_server."""

__author__ = """Chris Churas"""
__email__ = 'churas.camera@gmail.com'
__version__ = '0.0.1'

from datetime import datetime

import random
import os
import uuid
import copy
import flask
from flask import Flask, jsonify, request
from flask_restplus import reqparse, Api, Resource, fields, marshal
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address


desc = """DDOT REST Service 

 
 **NOTE:** This service is experimental. The interface is subject to change.


""" # noqa


random.seed(os.urandom(16))
DDOT_REST_SETTINGS_ENV = 'DDOT_REST_SETTINGS'
# global api object
app = Flask(__name__)

JOB_PATH_KEY = 'JOB_PATH'
WAIT_COUNT_KEY = 'WAIT_COUNT'
SLEEP_TIME_KEY = 'SLEEP_TIME'
DEFAULT_RATE_LIMIT_KEY = 'DEFAULT_RATE_LIMIT'

app.config[JOB_PATH_KEY] = '/tmp'
app.config[WAIT_COUNT_KEY] = 60
app.config[SLEEP_TIME_KEY] = 10
app.config[DEFAULT_RATE_LIMIT_KEY] = '360 per hour'

app.config.from_envvar(DDOT_REST_SETTINGS_ENV, silent=True)

LOCATION = 'Location'
DDOT_NS = 'ddot'


api = Api(app, version=str(__version__),
          title='DDOT ',
          description=desc, example='put example here')

# enable rate limiting
limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=[app.config[DEFAULT_RATE_LIMIT_KEY]],
    headers_enabled=True
)

# add rate limiting logger to the regular app logger
for handler in app.logger.handlers:
    limiter.logger.addHandler(handler)

# need to clear out the default namespace
api.namespaces.clear()

ns = api.namespace(DDOT_NS,
                   description='DDOT REST Service')

app.config.SWAGGER_UI_DOC_EXPANSION = 'list'

ERROR_RESP = api.model('ErrorResponseSchema', {
    'errorCode': fields.String(description='Error code to help identify issue'),
    'message': fields.String(description='Human readable description of error'),
    'description': fields.String(description='More detailed description of error'),
    'stackTrace': fields.String(description='stack trace of error'),
    'threadId': fields.String(description='Id of thread running process'),
    'timeStamp': fields.String(description='UTC Time stamp in YYYY-MM-DDTHH:MM.S')
})

TOO_MANY_REQUESTS = api.model('TooManyRequestsSchema', {
    'message': fields.String(description='Contains detailed message about exceeding request limits')
})

RATE_LIMIT_HEADERS = {
 'x-ratelimit-limit': 'Request rate limit',
 'x-ratelimit-remaining': 'Number of requests remaining',
 'x-ratelimit-reset': 'Request rate limit reset time'
}


class ErrorResponse(object):
    """Error response
    """
    

    def __init__(self):
        """
        Constructor
        """
        self.errorCode = ''
        self.message = ''
        self.description = ''
        self.stackTrace = ''
        self.threadId = ''
        self.timeStamp = ''

        dt = datetime.utcnow()
        self.timeStamp = dt.strftime('%Y-%m-%dT%H:%M.%s')


@api.doc('Runs query')
@ns.route('/ontology', strict_slashes=False)
class RunOntology(Resource):
    """
    Runs ontology
    """
    POST_HEADERS = RATE_LIMIT_HEADERS
    POST_HEADERS['Location'] = 'URL containing resource/result generated by this request'

    post_parser = reqparse.RequestParser()

    post_parser.add_argument('interactionfile', type=reqparse.FileStorage,
                             required=True,
                             help='tab delimited file with 3 columes like so: '
                                  'ARL2BP	DDAH1	0.5101',
                             location='files')
    post_parser.add_argument('alpha', type=float, default=0.05,
                             help='Sets alpha parameter',
                             location='form')
    post_parser.add_argument('beta', type=float, default=0.5,
                             help='Sets beta parameter',
                             location='form')

    @api.doc('Runs Ontology')
    @api.response(202, 'The task was successfully submitted to the service. '
                       'Visit the URL'
                       ' specified in **Location** field in HEADERS to '
                       'status and results', headers=POST_HEADERS)
    @api.response(429, 'Too many requests', TOO_MANY_REQUESTS, headers=RATE_LIMIT_HEADERS)
    @api.response(500, 'Internal server error', ERROR_RESP, headers=RATE_LIMIT_HEADERS)
    @api.expect(post_parser)
    def post(self):
        """
        Submits request

        The service should upon post return 202 and set location to resource to poll for result. Which will
        Match the URL of GET request below.
        """
        app.logger.debug("Post received")

        try:
            if random.choice(['success', 'fail']) is 'fail':
                raise Exception('something failed')

            res = str(uuid.uuid4())

            resp = flask.make_response()
            resp.headers[LOCATION] = DDOT_NS + '/' + res
            resp.status_code = 202
            return resp
        except Exception as ea:
            app.logger.exception('Error creating task due to Exception ' +
                                 str(ea))
            er = ErrorResponse()
            er.message = 'Error creating task due to Exception'
            er.description = str(ea)
            return marshal(er, ERROR_RESP), 500


@ns.route('/<string:id>', strict_slashes=False)
class GetQueryResult(Resource):
    """More class doc here"""



    @api.response(200, 'Successful response from server')
    @api.response(410, 'Task not found')
    @api.response(429, 'Too many requests', TOO_MANY_REQUESTS)
    @api.response(500, 'Internal server error', ERROR_RESP)
    def get(self, id):
        """
        Gets result of query. This endpoint will return partial results as they
        become available. Only after status is failed|complete are all results shown


        """

        er = ErrorResponse()
        er.message = 'implement this'
        er.description = 'more detailed error heehe'
        return marshal(er, ERROR_RESP), 500

    @api.doc('Creates request to delete query')
    @api.response(200, 'Delete request successfully received')
    @api.response(400, 'Invalid delete request', ERROR_RESP)
    @api.response(429, 'Too many requests', TOO_MANY_REQUESTS)
    @api.response(500, 'Internal server error', ERROR_RESP)
    def delete(self, id):
        """
        Deletes task associated with {id} passed in
        """
        s = random.choice([200, 400, 500])
        if s is 200:
            resp = flask.make_response()
            resp.status_code = s
            return resp

        er = ErrorResponse()
        if s is 400:
            er.message = 'Invalid request somehow'
            er.description = 'hi'
        if s is 500:
            er.message = 'some server error'
            er.description = 'hi there'

        return marshal(er, ERROR_RESP), s


class ServerStatus(object):
    """Represents status of server
    """
    def __init__(self):
        """Constructor
        """

        self.status = 'ok'
        self.message = ''
        self.pcdiskfull = 0
        self.load = [0, 0, 0]
        self.rest_version = __version__

        self.pcdiskfull = random.randint(0, 100)
        if self.pcdiskfull is 100:
            self.status = 'error'
            self.message = 'Disk is full'
        else:
            self.status = random.choice(['ok', 'error'])

        loadavg = os.getloadavg()

        self.load[0] = loadavg[0]
        self.load[1] = loadavg[1]
        self.load[2] = loadavg[2]

        self.queries[0] = random.randint(0, 500)
        self.queries[1] = self.queries[0] + random.randint(0, 500)
        self.queries[2] = self.queries[1] + random.randint(0, 500)
        self.queries[3] = self.queries[2] + random.randint(0, 500)
        self.queries[4] = self.queries[3] + random.randint(0, 500)


@ns.route('/status', strict_slashes=False)
class SystemStatus(Resource):

    OK_STATUS = 'ok'

    statusobj = api.model('StatusSchema', {
        'status': fields.String(description='ok|error'),
        'pcDiskFull': fields.Integer(description='How full disk is in %'),
        'load': fields.List(fields.Float(description='server load'),
                            description='List of 3 floats containing 1 minute,'
                                        ' 5 minute, 15minute load'),
        'restVersion': fields.String(description='Version of REST service')
    })
    @api.doc('Gets status')
    @api.response(200, 'Success', statusobj)
    @api.response(429, 'Too many requests', TOO_MANY_REQUESTS)
    @api.response(500, 'Internal server error', ERROR_RESP)
    def get(self):
        """
        Gets status of service

        """
        s_code = random.choice([200, 500])

        if s_code is 500:
            er = ErrorResponse()
            er.message = 'Internal server error'
            er.description = 'something good'
            return marshal(er, ERROR_RESP), s_code

        ss = ServerStatus()
        return marshal(ss, SystemStatus.statusobj), s_code
